<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.example.mapper.EmployeeMapper">
<!--    DML-->

    <delete id="deleteById" >
        delete from t_emp where emp_id = #{id}
    </delete>


<!--    1. 场景1： 返回单个简单类型如何指定 resultType的写法 返回值的数据类型
            resultTYpe语法：
                    类的全限定符
                    别名简称

                        mybatis给我们提供72中默认的别名
                        这些都是常用的Java数据类型
                              基本数据类型 int  double -> _int _double
                              包装数据类型  Integer Double -> int integer double
                              集合容器类型 Map List -> 小写接口 map list hashmap
                        如果没有提供需要自己定义 或者 类的全限定符号

              扩展：如果没有提供的需要自己定义的数据类型
              给自己的类如何定义别名:
     <typeAliases>
     mybatis-config.xml
        1. 各类单独定义别名
        <typeAlias type="org.example.mapper.EmployeeMapper" alias="ergouzi"/>
        2. 批量将包下的类给与别名，别名就是类的首字母小写
        <package name="org.example.org.example.pojo"/>
    </typeAliases>
    3. 如果不像使用批量的别名，可以使用注解给与名字；
    @Alias("ergouzi")

-->
<!--    <select id="queryById" resultType="ergouzi">-->
<!--        &lt;!&ndash; #{empId}代表动态传入的参数,并且进行赋值!后面详细讲解 &ndash;&gt;-->
<!--        select emp_id empId,emp_name empName, emp_salary empSalary from-->
<!--        t_emp where emp_id = #{id}-->
<!--    </select>-->


    <select id="queryNameById" resultType="string">
        select emp_name from t_emp where emp_id = #{id}
    </select>

    <select id="querySalaryById" resultType="double">
        select emp_salary from t_emp where emp_id = #{id}
    </select>

<!--    场景2： 返回单个自定义类类型
        reustType指定返回值类型即可
        默认要求：
           查询：返回单个是类型 要求别名和属性名一直，这样才可以进行实体类的属性映射。
        但是可以进行设置：设置支持驼峰式自动映射
        emp_id ====> empId
-->

    <!--        自动开启驼峰式自动映射 数据库 a_column  java AColumn
      emp_id -> empId === empId
      mybatis-config.xml中
    <setting name="mapUnderscoreToCamelCase" value="true"/>

     -->
    <select id="queryById" resultType="org.example.org.example.pojo.Employee">
            select * from
    t_emp where emp_id = #{id}
    </select>

<!--    场景3  返回map
        当没有实体类 可以接值的时候
        key -> 查询的列
        value -> 查询的值
-->
    <select id="selectEmpNameAndMaxSalary" resultType="map">
        SELECT
        emp_name 员工姓名,
        emp_salary 员工工资,
        (SELECT AVG(emp_salary) FROM t_emp) 部门平均工资
        FROM t_emp WHERE emp_salary=(
        SELECT MAX(emp_salary) FROM t_emp
        )
    </select>


<!--   场景4： 返回的是集合类型
     // 查询工资高于传入值的员工姓名们
    List<String> queryNamesBySalary(Double salary);


    // 查询全部员工信息
    List<Employee> queryAll();
    Employee queryById();

    切记： 如果返回的是结合，resultType 不需要指定集合类型，只需要指定泛型即可。
    为什么？
          mybatis -> ibatis -> selectOne 单个 ｜ selectlist 集合 -》 select one 调用 select list
 -->
    <select id="queryNamesBySalary" resultType="string">
        select emp_name from t_emp where emp_salary  > #{salary}
    </select>
    
    <select id="queryAll" resultType="employee">
        select * from t_emp
    </select>


<!--    场景5： 主键回显 获取插入数据的主键
        1。 自增长主键回显 mySQL auto_increment
        // 员工插入
        int insrtEmp(Employee employee);
        useGeneratedKeys="true" 我们想要数据库自动增长的主键值
        keyColumn="emp_id" 主键的列
        keyProperty="empId"  接收主键的属性
       
-->
    <insert id="insertEmp" useGeneratedKeys="true" keyColumn="emp_id" keyProperty="empId">
        insert into t_emp(emp_name,emp_salary)
        value(#{empName}, #{empSalary})
    </insert>
    
</mapper>
